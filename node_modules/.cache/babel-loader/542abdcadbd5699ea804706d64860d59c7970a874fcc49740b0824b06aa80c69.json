{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { isStorageError } from '../lib/errors';\nexport default class StreamDownloadBuilder {\n  constructor(downloadFn, shouldThrowOnError) {\n    this.downloadFn = downloadFn;\n    this.shouldThrowOnError = shouldThrowOnError;\n  }\n  then(onfulfilled, onrejected) {\n    return this.execute().then(onfulfilled, onrejected);\n  }\n  execute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const result = yield this.downloadFn();\n        return {\n          data: result.body,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n}","map":{"version":3,"names":["isStorageError","StreamDownloadBuilder","constructor","downloadFn","shouldThrowOnError","then","onfulfilled","onrejected","execute","result","data","body","error"],"sources":["C:\\Users\\hakimm\\Desktop\\beta\\node_modules\\@supabase\\storage-js\\src\\packages\\StreamDownloadBuilder.ts"],"sourcesContent":["import { isStorageError } from '../lib/errors'\r\nimport { DownloadResult } from '../lib/types'\r\n\r\nexport default class StreamDownloadBuilder implements PromiseLike<DownloadResult<ReadableStream>> {\r\n  constructor(private downloadFn: () => Promise<Response>, private shouldThrowOnError: boolean) {}\r\n\r\n  then<TResult1 = DownloadResult<ReadableStream>, TResult2 = never>(\r\n    onfulfilled?:\r\n      | ((value: DownloadResult<ReadableStream>) => TResult1 | PromiseLike<TResult1>)\r\n      | null,\r\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\r\n  ): Promise<TResult1 | TResult2> {\r\n    return this.execute().then(onfulfilled, onrejected)\r\n  }\r\n\r\n  private async execute(): Promise<DownloadResult<ReadableStream>> {\r\n    try {\r\n      const result = await this.downloadFn()\r\n\r\n      return {\r\n        data: result.body as ReadableStream,\r\n        error: null,\r\n      }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n\r\n      if (isStorageError(error)) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,cAAc,QAAQ,eAAe;AAG9C,eAAc,MAAOC,qBAAqB;EACxCC,YAAoBC,UAAmC,EAAUC,kBAA2B;IAAxE,KAAAD,UAAU,GAAVA,UAAU;IAAmC,KAAAC,kBAAkB,GAAlBA,kBAAkB;EAAY;EAE/FC,IAAIA,CACFC,WAEQ,EACRC,UAAuE;IAEvE,OAAO,IAAI,CAACC,OAAO,EAAE,CAACH,IAAI,CAACC,WAAW,EAAEC,UAAU,CAAC;EACrD;EAEcC,OAAOA,CAAA;;MACnB,IAAI;QACF,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACN,UAAU,EAAE;QAEtC,OAAO;UACLO,IAAI,EAAED,MAAM,CAACE,IAAsB;UACnCC,KAAK,EAAE;SACR;OACF,CAAC,OAAOA,KAAK,EAAE;QACd,IAAI,IAAI,CAACR,kBAAkB,EAAE;UAC3B,MAAMQ,KAAK;;QAGb,IAAIZ,cAAc,CAACY,KAAK,CAAC,EAAE;UACzB,OAAO;YAAEF,IAAI,EAAE,IAAI;YAAEE;UAAK,CAAE;;QAG9B,MAAMA,KAAK;;IAEf,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}