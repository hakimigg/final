{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst PostgrestQueryBuilder_1 = __importDefault(require(\"./PostgrestQueryBuilder\"));\nconst PostgrestFilterBuilder_1 = __importDefault(require(\"./PostgrestFilterBuilder\"));\n/**\r\n * PostgREST client.\r\n *\r\n * @typeParam Database - Types for the schema from the [type\r\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\r\n *\r\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\r\n * literal, the same one passed to the constructor. If the schema is not\r\n * `\"public\"`, this must be supplied manually.\r\n */\nclass PostgrestClient {\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\r\n   * Creates a PostgREST client.\r\n   *\r\n   * @param url - URL of the PostgREST endpoint\r\n   * @param options - Named parameters\r\n   * @param options.headers - Custom headers\r\n   * @param options.schema - Postgres schema to switch to\r\n   * @param options.fetch - Custom fetch\r\n   */\n  constructor(url) {\n    let {\n      headers = {},\n      schema,\n      fetch\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.url = url;\n    this.headers = new Headers(headers);\n    this.schemaName = schema;\n    this.fetch = fetch;\n  }\n  /**\r\n   * Perform a query on a table or a view.\r\n   *\r\n   * @param relation - The table or view name to query\r\n   */\n  from(relation) {\n    const url = new URL(\"\".concat(this.url, \"/\").concat(relation));\n    return new PostgrestQueryBuilder_1.default(url, {\n      headers: new Headers(this.headers),\n      schema: this.schemaName,\n      fetch: this.fetch\n    });\n  }\n  /**\r\n   * Select a schema to query or perform an function (rpc) call.\r\n   *\r\n   * The schema needs to be on the list of exposed schemas inside Supabase.\r\n   *\r\n   * @param schema - The schema to query\r\n   */\n  schema(schema) {\n    return new PostgrestClient(this.url, {\n      headers: this.headers,\n      schema,\n      fetch: this.fetch\n    });\n  }\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn - The function name to call\r\n   * @param args - The arguments to pass to the function call\r\n   * @param options - Named parameters\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   * @param options.get - When set to `true`, the function will be called with\r\n   * read-only access mode.\r\n   * @param options.count - Count algorithm to use to count rows returned by the\r\n   * function. Only applicable for [set-returning\r\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\n  rpc(fn) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let {\n      head = false,\n      get = false,\n      count\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _a;\n    let method;\n    const url = new URL(\"\".concat(this.url, \"/rpc/\").concat(fn));\n    let body;\n    if (head || get) {\n      method = head ? 'HEAD' : 'GET';\n      Object.entries(args)\n      // params with undefined value needs to be filtered out, otherwise it'll\n      // show up as `?param=undefined`\n      .filter(_ref => {\n        let [_, value] = _ref;\n        return value !== undefined;\n      })\n      // array values need special syntax\n      .map(_ref2 => {\n        let [name, value] = _ref2;\n        return [name, Array.isArray(value) ? \"{\".concat(value.join(','), \"}\") : \"\".concat(value)];\n      }).forEach(_ref3 => {\n        let [name, value] = _ref3;\n        url.searchParams.append(name, value);\n      });\n    } else {\n      method = 'POST';\n      body = args;\n    }\n    const headers = new Headers(this.headers);\n    if (count) {\n      headers.set('Prefer', \"count=\".concat(count));\n    }\n    return new PostgrestFilterBuilder_1.default({\n      method,\n      url,\n      headers,\n      schema: this.schemaName,\n      body,\n      fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n    });\n  }\n}\nexports.default = PostgrestClient;","map":{"version":3,"names":["PostgrestQueryBuilder_1","__importDefault","require","PostgrestFilterBuilder_1","PostgrestClient","constructor","url","headers","schema","fetch","arguments","length","undefined","Headers","schemaName","from","relation","URL","concat","default","rpc","fn","args","head","get","count","method","body","Object","entries","filter","_ref","_","value","map","_ref2","name","Array","isArray","join","forEach","_ref3","searchParams","append","set","_a","exports"],"sources":["C:\\Users\\hakimm\\Desktop\\beta\\node_modules\\@supabase\\postgrest-js\\src\\PostgrestClient.ts"],"sourcesContent":["import PostgrestQueryBuilder from './PostgrestQueryBuilder'\r\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\r\nimport { Fetch, GenericSchema, ClientServerOptions } from './types'\r\n\r\n/**\r\n * PostgREST client.\r\n *\r\n * @typeParam Database - Types for the schema from the [type\r\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\r\n *\r\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\r\n * literal, the same one passed to the constructor. If the schema is not\r\n * `\"public\"`, this must be supplied manually.\r\n */\r\nexport default class PostgrestClient<\r\n  Database = any,\r\n  ClientOptions extends ClientServerOptions = Database extends {\r\n    __InternalSupabase: infer I extends ClientServerOptions\r\n  }\r\n    ? I\r\n    : {},\r\n  SchemaName extends string &\r\n    keyof Omit<Database, '__InternalSupabase'> = 'public' extends keyof Omit<\r\n    Database,\r\n    '__InternalSupabase'\r\n  >\r\n    ? 'public'\r\n    : string & keyof Omit<Database, '__InternalSupabase'>,\r\n  Schema extends GenericSchema = Omit<\r\n    Database,\r\n    '__InternalSupabase'\r\n  >[SchemaName] extends GenericSchema\r\n    ? Omit<Database, '__InternalSupabase'>[SchemaName]\r\n    : any\r\n> {\r\n  url: string\r\n  headers: Headers\r\n  schemaName?: SchemaName\r\n  fetch?: Fetch\r\n\r\n  // TODO: Add back shouldThrowOnError once we figure out the typings\r\n  /**\r\n   * Creates a PostgREST client.\r\n   *\r\n   * @param url - URL of the PostgREST endpoint\r\n   * @param options - Named parameters\r\n   * @param options.headers - Custom headers\r\n   * @param options.schema - Postgres schema to switch to\r\n   * @param options.fetch - Custom fetch\r\n   */\r\n  constructor(\r\n    url: string,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      fetch,\r\n    }: {\r\n      headers?: HeadersInit\r\n      schema?: SchemaName\r\n      fetch?: Fetch\r\n    } = {}\r\n  ) {\r\n    this.url = url\r\n    this.headers = new Headers(headers)\r\n    this.schemaName = schema\r\n    this.fetch = fetch\r\n  }\r\n  from<\r\n    TableName extends string & keyof Schema['Tables'],\r\n    Table extends Schema['Tables'][TableName]\r\n  >(relation: TableName): PostgrestQueryBuilder<ClientOptions, Schema, Table, TableName>\r\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\r\n    relation: ViewName\r\n  ): PostgrestQueryBuilder<ClientOptions, Schema, View, ViewName>\r\n  /**\r\n   * Perform a query on a table or a view.\r\n   *\r\n   * @param relation - The table or view name to query\r\n   */\r\n  from(relation: string): PostgrestQueryBuilder<ClientOptions, Schema, any, any> {\r\n    const url = new URL(`${this.url}/${relation}`)\r\n    return new PostgrestQueryBuilder(url, {\r\n      headers: new Headers(this.headers),\r\n      schema: this.schemaName,\r\n      fetch: this.fetch,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Select a schema to query or perform an function (rpc) call.\r\n   *\r\n   * The schema needs to be on the list of exposed schemas inside Supabase.\r\n   *\r\n   * @param schema - The schema to query\r\n   */\r\n  schema<DynamicSchema extends string & keyof Omit<Database, '__InternalSupabase'>>(\r\n    schema: DynamicSchema\r\n  ): PostgrestClient<\r\n    Database,\r\n    ClientOptions,\r\n    DynamicSchema,\r\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\r\n  > {\r\n    return new PostgrestClient(this.url, {\r\n      headers: this.headers,\r\n      schema,\r\n      fetch: this.fetch,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn - The function name to call\r\n   * @param args - The arguments to pass to the function call\r\n   * @param options - Named parameters\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   * @param options.get - When set to `true`, the function will be called with\r\n   * read-only access mode.\r\n   * @param options.count - Count algorithm to use to count rows returned by the\r\n   * function. Only applicable for [set-returning\r\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  rpc<FnName extends string & keyof Schema['Functions'], Fn extends Schema['Functions'][FnName]>(\r\n    fn: FnName,\r\n    args: Fn['Args'] = {},\r\n    {\r\n      head = false,\r\n      get = false,\r\n      count,\r\n    }: {\r\n      head?: boolean\r\n      get?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<\r\n    ClientOptions,\r\n    Schema,\r\n    Fn['Returns'] extends any[]\r\n      ? Fn['Returns'][number] extends Record<string, unknown>\r\n        ? Fn['Returns'][number]\r\n        : never\r\n      : never,\r\n    Fn['Returns'],\r\n    FnName,\r\n    null,\r\n    'RPC'\r\n  > {\r\n    let method: 'HEAD' | 'GET' | 'POST'\r\n    const url = new URL(`${this.url}/rpc/${fn}`)\r\n    let body: unknown | undefined\r\n    if (head || get) {\r\n      method = head ? 'HEAD' : 'GET'\r\n      Object.entries(args)\r\n        // params with undefined value needs to be filtered out, otherwise it'll\r\n        // show up as `?param=undefined`\r\n        .filter(([_, value]) => value !== undefined)\r\n        // array values need special syntax\r\n        .map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(',')}}` : `${value}`])\r\n        .forEach(([name, value]) => {\r\n          url.searchParams.append(name, value)\r\n        })\r\n    } else {\r\n      method = 'POST'\r\n      body = args\r\n    }\r\n\r\n    const headers = new Headers(this.headers)\r\n    if (count) {\r\n      headers.set('Prefer', `count=${count}`)\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url,\r\n      headers,\r\n      schema: this.schemaName,\r\n      body,\r\n      fetch: this.fetch ?? fetch,\r\n    })\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}